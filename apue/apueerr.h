#include "apue.h"
#include <errno.h>      /* for definition of errno */
#include <stdarg.h>     /* ISO C variable aruments */

static void err_doit(int, int, const char *, va_list);

/*
* Nonfatal error related to a system call.
* Print a message and return.
*/
void
err_ret(const char *fmt, ...)
{
    va_list     ap;

    va_start(ap, fmt);
    err_doit(1, errno, fmt, ap);
    va_end(ap);
}

/*
* Fatal error related to a system call.
* Print a message and terminate.
*/
void
err_sys(const char *fmt, ...)
{
    va_list     ap;

    va_start(ap, fmt);
    err_doit(1, errno, fmt, ap);
    va_end(ap);
    exit(1);
}

/*
* Fatal error unrelated to a system call.
* Error code passed as explict parameter.
* Print a message and terminate.
*/
void
err_exit(int error, const char *fmt, ...)
{
    va_list     ap;

    va_start(ap, fmt);
    err_doit(1, error, fmt, ap);
    va_end(ap);
    exit(1);
}

/*
* Fatal error related to a system call.
* Print a message, dump core, and terminate.
*/
void
err_dump(const char *fmt, ...)
{
    va_list     ap;

    va_start(ap, fmt);
    err_doit(1, errno, fmt, ap);
    va_end(ap);
    abort();        /* dump core and terminate */
    exit(1);        /* shouldn't get here */
}

/*
* Nonfatal error unrelated to a system call.
* Print a message and return.
*/
void
err_msg(const char *fmt, ...)
{
    va_list     ap;

    va_start(ap, fmt);
    err_doit(0, 0, fmt, ap);
    va_end(ap);
}

/*
* Fatal error unrelated to a system call.
* Print a message and terminate.
*/
void
err_quit(const char *fmt, ...)
{
    va_list     ap;

    va_start(ap, fmt);
    err_doit(0, 0, fmt, ap);
    va_end(ap);
    exit(1);
}

/*
* Print a message and return to caller.
* Caller specifies "errnoflag".
*/
static void
err_doit(int errnoflag, int error, const char *fmt, va_list ap)
{
    char    buf[MAXLINE];
   vsnprintf(buf, MAXLINE, fmt, ap);
   if (errnoflag)
       snprintf(buf+strlen(buf), MAXLINE-strlen(buf), ": %s",
         strerror(error));
   strcat(buf, " \n");
   fflush(stdout);     /* in case stdout and stderr are the same */
   fputs(buf, stderr);
   fflush(NULL);       /* flushes all stdio output streams */
}

#ifdef   PATH_MAX 
static int   pathmax = PATH_MAX; 
#else 
static int   pathmax = 0; 
#endif 
#define SUSV3 200112L 
static long posix_version = 0; 
/* If PATH_MAX is indeterminate, no guarantee this is adequate */ 
#define PATH_MAX_GUESS   1024 
char * 
path_alloc(int *sizep) /* also return allocated size, if nonnull */ 
{ 
	char *ptr; 
	int size; 
	if (posix_version == 0) 
		   posix_version = sysconf(_SC_VERSION); 
	if (pathmax == 0) {     /* first time through */ 
		   errno = 0; 
		   if ((pathmax = pathconf("/", _PC_PATH_MAX)) < 0) { 
			 if (errno == 0) 
				pathmax = PATH_MAX_GUESS; /* it's indeterminate */ 
			 else 
				err_sys("pathconf error for _PC_PATH_MAX"); 
		   } else { 
			 pathmax++;    /* add one since it's relative to root */ 
		   } 
	} 
	if (posix_version < SUSV3) 
		   size = pathmax + 1; 
	else 
		   size = pathmax; 
	if ((ptr = malloc(size)) == NULL) 
		   err_sys("malloc error for pathname"); 
	if (sizep != NULL) 
		   *sizep = size; 
	return(ptr); 
} 
void pr_exit(int status)
{
	if(WIFEXITED(status))
		printf("normal termination, exit status = %d\n", WEXITSTATUS(status));
	else if(WIFSIGNALED(status))
		printf("abnormal termination, signal number = %d%s\n", WTERMSIG(status),
#ifdef	WCOREDUMP
		WCOREDUMP(status) ? " (core file generated" : "";
#else
		"");
#endif
	else if(WIFSTOPPED(status))
		printf("child stopped, signal number = %d\n", WSTOPSIG(status));
}
